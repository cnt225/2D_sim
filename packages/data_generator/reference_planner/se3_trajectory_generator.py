#!/usr/bin/env python3
"""
SE(3) Trajectory GT Generator
Í∏∞Ï°¥ SE(3) pose pairsÎ•º ÏÇ¨Ïö©ÌïòÏó¨ RRT-ConnectÎ°ú trajectory GT ÏÉùÏÑ±

Ï£ºÏöî Í∏∞Îä•:
- SE(3) pose pairs Î°úÎìú
- RRT-ConnectÎ°ú trajectory Í≥ÑÌöç
- collision_detectorÏôÄ Ïó∞ÎèôÎêú isStateValid
- Trajectory GT JSON Ï†ÄÏû•
"""

import json
import time
from pathlib import Path
from typing import List, Dict, Any, Optional
import argparse

# SE(3) RRT planner import
from rrt_connect import create_se3_planner, SE3TrajectoryResult


class SE3TrajectoryGTGenerator:
    """SE(3) Trajectory GT ÏÉùÏÑ±Í∏∞"""
    
    def __init__(self, rigid_body_id: int, pointcloud_file: str = None):
        """
        Args:
            rigid_body_id: Rigid body ID (0-3)
            pointcloud_file: ÌôòÍ≤Ω PLY ÌååÏùº Í≤ΩÎ°ú (optional)
        """
        self.rigid_body_id = rigid_body_id
        self.pointcloud_file = pointcloud_file
        
        # SE(3) RRT planner ÏÉùÏÑ±
        self.planner = create_se3_planner(rigid_body_id, pointcloud_file)
        
        # ÌÜµÍ≥Ñ
        self.stats = {
            "total_pairs": 0,
            "successful_plans": 0,
            "failed_plans": 0,
            "total_planning_time": 0.0,
            "avg_planning_time": 0.0,
            "avg_path_length": 0.0,
            "avg_waypoints": 0.0
        }
        
        print(f"‚úÖ SE(3) Trajectory GT Generator initialized")
        print(f"   - Rigid body ID: {rigid_body_id}")
        print(f"   - Environment: {pointcloud_file or 'empty'}")
    
    def load_pose_pairs(self, pose_pairs_file: str) -> List[Dict[str, Any]]:
        """SE(3) pose pairs JSON ÌååÏùº Î°úÎìú"""
        try:
            with open(pose_pairs_file, 'r') as f:
                data = json.load(f)
            
            # pose_pairs.dataÏóêÏÑú Ïã§Ï†ú pairs Ï∂îÏ∂ú
            if 'pose_pairs' in data and 'data' in data['pose_pairs']:
                pairs = data['pose_pairs']['data']
            else:
                # Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ ÏßÅÏ†ë Î¶¨Ïä§Ìä∏Ïù∏ Í≤ΩÏö∞ÎèÑ Ï≤òÎ¶¨
                pairs = data if isinstance(data, list) else []
            
            print(f"‚úÖ Loaded pose pairs from: {pose_pairs_file}")
            print(f"   - Total pairs: {len(pairs)}")
            
            return pairs
            
        except Exception as e:
            print(f"‚ùå Failed to load pose pairs: {e}")
            return []
    
    def generate_trajectory(self, start_pose: List[float], goal_pose: List[float], 
                          max_planning_time: float = 5.0) -> Optional[SE3TrajectoryResult]:
        """Îã®Ïùº trajectory ÏÉùÏÑ±"""
        try:
            result = self.planner.plan_trajectory(start_pose, goal_pose, max_planning_time)
            
            # ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self.stats["total_planning_time"] += result.planning_time
            
            if result.success:
                self.stats["successful_plans"] += 1
            else:
                self.stats["failed_plans"] += 1
            
            return result
            
        except Exception as e:
            print(f"‚ùå Trajectory generation error: {e}")
            self.stats["failed_plans"] += 1
            return None
    
    def generate_trajectories_from_poses(self, pose_pairs: List[Dict[str, Any]], 
                                       max_planning_time: float = 5.0,
                                       output_dir: str = "trajectories") -> List[Dict[str, Any]]:
        """Ïó¨Îü¨ pose pairsÏóêÏÑú trajectories ÏÉùÏÑ±"""
        
        self.stats["total_pairs"] = len(pose_pairs)
        trajectories = []
        
        print(f"üöÄ Generating {len(pose_pairs)} trajectories...")
        
        # Output directory ÏÉùÏÑ±
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        for i, pose_pair in enumerate(pose_pairs):
            print(f"\n--- Trajectory {i+1}/{len(pose_pairs)} ---")
            
            try:
                # Pose pairÏóêÏÑú start, goal Ï∂îÏ∂ú
                start_pose = pose_pair.get("init")
                goal_pose = pose_pair.get("target")
                
                if not start_pose or not goal_pose:
                    print(f"‚ö†Ô∏è Invalid pose pair format, skipping...")
                    continue
                
                print(f"Start: [{start_pose[0]:.2f}, {start_pose[1]:.2f}, {start_pose[5]:.2f}]")
                print(f"Goal:  [{goal_pose[0]:.2f}, {goal_pose[1]:.2f}, {goal_pose[5]:.2f}]")
                
                # Trajectory ÏÉùÏÑ±
                result = self.generate_trajectory(start_pose, goal_pose, max_planning_time)
                
                if result and result.success:
                    print(f"‚úÖ Success: {result.num_waypoints} waypoints, "
                          f"time: {result.planning_time:.3f}s")
                    
                    # Trajectory data Íµ¨ÏÑ±
                    trajectory_data = {
                        "pair_id": i,
                        "trajectory_id": f"traj_rb{self.rigid_body_id}_{i:06d}",
                        "rigid_body": {
                            "id": self.rigid_body_id,
                            "type": self.planner.config.name
                        },
                        "environment": {
                            "name": Path(self.pointcloud_file).stem if self.pointcloud_file else "empty",
                            "ply_file": self.pointcloud_file
                        },
                        "start_pose": start_pose,
                        "goal_pose": goal_pose,
                        "path": {
                            "data": result.trajectory,
                            "format": "se3_trajectory",
                            "length": result.num_waypoints,
                            "planning_time": result.planning_time,
                            "path_length": result.path_length,
                            "timestamps": result.timestamps
                        },
                        "planning_method": "RRT-Connect",
                        "generation_info": {
                            "success": True,
                            "max_planning_time": max_planning_time,
                            "planner_settings": result.planner_settings,
                            "metadata": result.metadata
                        }
                    }
                    
                    trajectories.append(trajectory_data)
                    
                    # Individual trajectory ÌååÏùº Ï†ÄÏû•
                    traj_file = output_path / f"trajectory_{i:06d}.json"
                    with open(traj_file, 'w') as f:
                        json.dump(trajectory_data, f, indent=2)
                    
                else:
                    print(f"‚ùå Failed: {result.metadata if result else 'Unknown error'}")
            
            except Exception as e:
                print(f"‚ùå Error processing pair {i}: {e}")
                self.stats["failed_plans"] += 1
        
        # ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        self._calculate_final_stats(trajectories)
        
        return trajectories
    
    def _calculate_final_stats(self, trajectories: List[Dict[str, Any]]):
        """ÏµúÏ¢Ö ÌÜµÍ≥Ñ Í≥ÑÏÇ∞"""
        if self.stats["total_pairs"] > 0:
            self.stats["avg_planning_time"] = self.stats["total_planning_time"] / self.stats["total_pairs"]
        
        if trajectories:
            self.stats["avg_path_length"] = sum(t["path"]["path_length"] for t in trajectories) / len(trajectories)
            self.stats["avg_waypoints"] = sum(t["path"]["length"] for t in trajectories) / len(trajectories)
    
    def save_trajectory_batch(self, trajectories: List[Dict[str, Any]], output_file: str):
        """Trajectory batch JSON Ï†ÄÏû•"""
        batch_data = {
            "batch_info": {
                "rigid_body_id": self.rigid_body_id,
                "environment_file": self.pointcloud_file,
                "total_trajectories": len(trajectories),
                "generation_time": time.strftime('%Y-%m-%d %H:%M:%S')
            },
            "statistics": self.stats,
            "trajectories": trajectories
        }
        
        with open(output_file, 'w') as f:
            json.dump(batch_data, f, indent=2)
        
        print(f"‚úÖ Trajectory batch saved to: {output_file}")
    
    def print_statistics(self):
        """ÌÜµÍ≥Ñ Ï∂úÎ†•"""
        print(f"\nüìä SE(3) Trajectory Generation Statistics:")
        print(f"   Total pairs: {self.stats['total_pairs']}")
        print(f"   Successful: {self.stats['successful_plans']}")
        print(f"   Failed: {self.stats['failed_plans']}")
        if self.stats['total_pairs'] > 0:
            success_rate = self.stats['successful_plans'] / self.stats['total_pairs'] * 100
            print(f"   Success rate: {success_rate:.1f}%")
        print(f"   Avg planning time: {self.stats['avg_planning_time']:.3f}s")
        print(f"   Avg path length: {self.stats['avg_path_length']:.3f}")
        print(f"   Avg waypoints: {self.stats['avg_waypoints']:.1f}")


def main():
    """Main function for command line usage"""
    parser = argparse.ArgumentParser(description="Generate SE(3) trajectory GT from pose pairs")
    parser.add_argument("--rigid_body_id", type=int, default=3, help="Rigid body ID (0-3)")
    parser.add_argument("--pose_pairs_file", required=True, help="Input pose pairs JSON file")
    parser.add_argument("--pointcloud_file", help="Environment PLY file (optional)")
    parser.add_argument("--output_dir", default="trajectories", help="Output directory")
    parser.add_argument("--max_planning_time", type=float, default=5.0, help="Max planning time per trajectory")
    parser.add_argument("--batch_file", help="Output batch JSON file")
    
    args = parser.parse_args()
    
    # Generator ÏÉùÏÑ±
    generator = SE3TrajectoryGTGenerator(args.rigid_body_id, args.pointcloud_file)
    
    # Pose pairs Î°úÎìú
    pose_pairs = generator.load_pose_pairs(args.pose_pairs_file)
    if not pose_pairs:
        print("‚ùå No pose pairs loaded, exiting...")
        return
    
    # Trajectories ÏÉùÏÑ±
    trajectories = generator.generate_trajectories_from_poses(
        pose_pairs, 
        max_planning_time=args.max_planning_time,
        output_dir=args.output_dir
    )
    
    # Batch ÌååÏùº Ï†ÄÏû•
    if args.batch_file:
        generator.save_trajectory_batch(trajectories, args.batch_file)
    
    # ÌÜµÍ≥Ñ Ï∂úÎ†•
    generator.print_statistics()


if __name__ == "__main__":
    # Example usage
    if len(__import__('sys').argv) == 1:
        print("üß™ SE(3) Trajectory GT Generator Example")
        
        # Test parameters
        rigid_body_id = 3
        pose_pairs_file = "../pose/pose_pairs/elongated_ellipse_poses.json"
        pointcloud_file = "../../simulation/robot_simulation/legacy/simple_endeffector_sim/data/pointcloud/circles_only/circles_only.ply"
        
        try:
            # Create generator
            generator = SE3TrajectoryGTGenerator(rigid_body_id, pointcloud_file)
            
            # Load pose pairs
            pose_pairs = generator.load_pose_pairs(pose_pairs_file)
            
            if pose_pairs:
                # Generate first 3 trajectories for testing
                test_pairs = pose_pairs[:3]
                trajectories = generator.generate_trajectories_from_poses(
                    test_pairs, 
                    max_planning_time=3.0,
                    output_dir="results"
                )
                
                # Save batch
                generator.save_trajectory_batch(trajectories, "test_trajectory_batch.json")
                generator.print_statistics()
            else:
                print("‚ùå No pose pairs found for testing")
                
        except Exception as e:
            print(f"‚ùå Example failed: {e}")
            import traceback
            traceback.print_exc()
    else:
        main() 